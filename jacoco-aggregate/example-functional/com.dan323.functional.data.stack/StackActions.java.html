<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StackActions.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Functionals by annotation in Java</a> &gt; <a href="../index.html" class="el_bundle">example-functional</a> &gt; <a href="index.source.html" class="el_package">com.dan323.functional.data.stack</a> &gt; <span class="el_source">StackActions.java</span></div><h1>StackActions.java</h1><pre class="source lang-java linenums">package com.dan323.functional.data.stack;

import com.dan323.functional.data.either.Either;
import com.dan323.functional.data.function.FunctionFrom;
import com.dan323.functional.data.list.FiniteList;
import com.dan323.functional.data.list.List;
import com.dan323.functional.data.optional.Maybe;
import com.dan323.functional.data.optional.MaybeMonad;
import com.dan323.functional.data.pair.Pair;
import com.dan323.functional.data.state.StateMonad;
import com.dan323.functional.data.state.StateWithError;

import java.util.Objects;
import java.util.function.Function;
import java.util.function.UnaryOperator;

/**
 * Actions to take in a stack, represented as a finite list {@link FiniteList&lt;A&gt;}
 *
 * @param &lt;A&gt; type of elements in the stack
 */
public final class StackActions&lt;A&gt; implements StateWithError&lt;Maybe&lt;A&gt;, FiniteList&lt;A&gt;, StackActions.StackError&gt; {

    public static class StackError {

        private final String message;

<span class="fc" id="L28">        private StackError(String message) {</span>
<span class="fc" id="L29">            this.message = message;</span>
<span class="fc" id="L30">        }</span>

        public static StackError poppingEmpty() {
<span class="fc" id="L33">            return new StackError(&quot;Cannot perform this action on an empty stack&quot;);</span>
        }

        public static StackError illegalState() {
<span class="fc" id="L37">            return new StackError(&quot;This state should be unreachable&quot;);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L42">            return &quot;[ERROR]: &quot; + message;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L47" title="2 of 4 branches missed.">            return (obj instanceof StackError stackError) &amp;&amp; Objects.equals(stackError.message, message);</span>
        }
    }

    private final StateWithError&lt;Maybe&lt;A&gt;, FiniteList&lt;A&gt;, StackError&gt; state;

<span class="fc" id="L53">    private StackActions(StateWithError&lt;Maybe&lt;A&gt;, FiniteList&lt;A&gt;, StackError&gt; state) {</span>
<span class="fc" id="L54">        this.state = state;</span>
<span class="fc" id="L55">    }</span>

    // PURE BASIC ACTIONS

    /**
     * Add an element to the stack
     *
     * @param x   element to add
     * @param &lt;A&gt; type of elements in the stack
     * @return ... -&gt; ... x |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; push(A x) {
<span class="fc" id="L67">        return new StackActions&lt;&gt;(s -&gt; Either.right(new Pair&lt;&gt;(Maybe.of(), FiniteList.cons(x, s))));</span>
    }

    /**
     * Extract the top most element
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... x -&gt; ... | x
     */
    public static &lt;A&gt; StackActions&lt;A&gt; pop() {
<span class="fc" id="L77">        return new StackActions&lt;&gt;(s -&gt; s.head().maybe(h -&gt; Either.right(new Pair&lt;&gt;(Maybe.of(h), s.tail())), Either.left(StackError.poppingEmpty())));</span>
    }

    /**
     * &lt;p&gt;
     * Reset the state to be empty.
     * &lt;/p&gt;&lt;p&gt;
     * TO BE USED ONLY FOR TESTING PURPOSES
     * &lt;/p&gt;
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... -&gt; |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; reset() {
<span class="nc" id="L91">        return new StackActions&lt;&gt;(s -&gt; Either.right(new Pair&lt;&gt;(Maybe.of(), FiniteList.nil())));</span>
    }

    /**
     * Modify the topmost element
     *
     * @param modif function to apply
     * @param &lt;A&gt;   type of elements in the stack
     * @return ... x -&gt; ... modif(x)
     */
    public static &lt;A&gt; StackActions&lt;A&gt; modify(UnaryOperator&lt;A&gt; modif) {
<span class="nc" id="L102">        return StackActions.&lt;A&gt;pop().thenByPopped(m -&gt; MaybeMonad.map(m, modif).maybe(StackActions::push, error(StackError.illegalState())));</span>
    }

    /**
     * stack that fails
     *
     * @param stackError error to fail with
     * @param &lt;A&gt;        type of elements in the stack
     * @return ... -&gt; ERROR
     */
    public static &lt;A&gt; StackActions&lt;A&gt; error(StackError stackError) {
<span class="pc" id="L113">        return new StackActions&lt;&gt;(s -&gt; Either.left(stackError));</span>
    }

    /**
     * Remove the top most element
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... x -&gt; ... |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; drop() {
<span class="fc" id="L123">        return StackActions.&lt;A&gt;pop().then(doNothing());</span>
    }

    /**
     * Leave the state as is, no output
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... -&gt; ... |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; doNothing() {
<span class="fc" id="L133">        return new StackActions&lt;&gt;(s -&gt; Either.right(new Pair&lt;&gt;(Maybe.of(), s)));</span>
    }

    /**
     * Duplicate the top most element
     *
     * @param &lt;A&gt; type of the elements in the stack
     * @return ... x -&gt; ... x x |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; dup() {
<span class="fc" id="L143">        return StackActions.&lt;A&gt;pop().thenByPopped(m -&gt; m.maybe(x -&gt; push(x).then(push(x)), error(StackError.illegalState())));</span>
    }

    /**
     * Interchange the 2 topmost elements in the stack
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... x y -&gt; ... y x |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; swap() {
<span class="nc" id="L153">        return StackActions.&lt;A&gt;pop().thenByPopped(m -&gt; m.maybe(x -&gt; StackActions.&lt;A&gt;pop().thenByPopped(n -&gt; n.maybe(h -&gt; StackActions.&lt;A&gt;push(x).then(push(h)), error(StackError.illegalState()))), error(StackError.illegalState())));</span>
    }

    /**
     * Copy the over the topmost element in the stack
     *
     * @param &lt;A&gt; type of elements in the stack
     * @return ... x y -&gt; ... x y x |
     */
    public static &lt;A&gt; StackActions&lt;A&gt; over() {
<span class="fc" id="L163">        return StackActions.&lt;A&gt;pop().thenByPopped(m -&gt; m.maybe(x -&gt; StackActions.&lt;A&gt;pop().thenByPopped(n -&gt; n.maybe(h -&gt; StackActions.&lt;A&gt;push(h).then(push(x)).then(push(h)), error(StackError.illegalState()))), error(StackError.illegalState())));</span>
    }

    // CONCATENATIONS

    /**
     * Concatenate a different stack action depending on the previous output
     *
     * @param fun dependency
     * @return concatenated stack actions first the current one and after, fun applied to the output of this one
     * @see #then(StackActions)
     */
    public StackActions&lt;A&gt; thenByPopped(Function&lt;Maybe&lt;A&gt;, StackActions&lt;A&gt;&gt; fun) {
<span class="fc" id="L176">        Function&lt;Maybe&lt;A&gt;, StateWithError&lt;Maybe&lt;A&gt;, FiniteList&lt;A&gt;, StackError&gt;&gt; ff = t -&gt; fun.apply(t).state;</span>
<span class="fc" id="L177">        return new StackActions&lt;&gt;(StateMonad.&lt;FiniteList&lt;A&gt;, StackError&gt;getInstance().flatMap(ff, this.state));</span>
    }

    /**
     * Concatenate stack actions
     *
     * @param st next action
     * @return a stack action that performs them in sequence
     * @see #thenByPopped(Function)
     */
    public StackActions&lt;A&gt; then(StackActions&lt;A&gt; st) {
<span class="fc" id="L188">        return this.thenByPopped(FunctionFrom.&lt;Maybe&lt;A&gt;&gt;getInstance().pure(st));</span>
    }

    /**
     * Print the final pair {@link Maybe&lt;A&gt;} and {@link List&lt;A&gt;} of the stack starting with an empty list
     *
     * @return the left error or the right pair result to apply this state to an empty list
     * @see Pair#toString()
     * @see com.dan323.functional.data.either.Left#toString()
     * @see com.dan323.functional.data.either.Right#toString()
     */
    public String toString() {
<span class="nc" id="L200">        return apply(FiniteList.nil()).toString();</span>
    }

    @Override
    public Either&lt;StackError, Pair&lt;Maybe&lt;A&gt;, FiniteList&lt;A&gt;&gt;&gt; apply(FiniteList&lt;A&gt; aList) {
<span class="fc" id="L205">        return state.apply(aList);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>